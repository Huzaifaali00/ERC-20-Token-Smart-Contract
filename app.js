
const contractAddress = "0x848744ad263Cb9008D265Cb60B086A9e6FFe19B9";
const contractABI = [
    { "type": "constructor", "inputs": [], "stateMutability": "nonpayable" }, { "type": "fallback", "stateMutability": "payable" }, { "type": "receive", "stateMutability": "payable" }, { "type": "function", "name": "add_supply", "inputs": [], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "view" }, { "type": "function", "name": "all_users", "inputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "outputs": [{ "name": "", "type": "address", "internalType": "address" }], "stateMutability": "view" }, { "type": "function", "name": "balance_sheet", "inputs": [{ "name": "", "type": "address", "internalType": "address" }], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "view" }, { "type": "function", "name": "buy_token", "inputs": [], "outputs": [], "stateMutability": "payable" }, { "type": "function", "name": "executeAirdrop", "inputs": [{ "name": "user", "type": "address", "internalType": "address" }, { "name": "tokens", "type": "uint256", "internalType": "uint256" }], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "nonpayable" }, { "type": "function", "name": "getContractMgBalance", "inputs": [], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "view" }, { "type": "function", "name": "get_your_tokens", "inputs": [], "outputs": [], "stateMutability": "nonpayable" }, { "type": "function", "name": "getbalance", "inputs": [], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "view" }, { "type": "function", "name": "index", "inputs": [], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "view" }, { "type": "function", "name": "max_limit", "inputs": [], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "view" }, { "type": "function", "name": "owner_supply", "inputs": [], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "view" }, { "type": "function", "name": "price_per_token", "inputs": [], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "view" }, { "type": "function", "name": "sell_tokens", "inputs": [{ "name": "token_to_sell", "type": "uint256", "internalType": "uint256" }], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "nonpayable" }, { "type": "function", "name": "start_mining", "inputs": [], "outputs": [], "stateMutability": "nonpayable" }, { "type": "function", "name": "stop_mining", "inputs": [], "outputs": [], "stateMutability": "nonpayable" }, { "type": "function", "name": "token", "inputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "view" }, { "type": "function", "name": "token_name", "inputs": [], "outputs": [{ "name": "", "type": "string", "internalType": "string" }], "stateMutability": "view" }, { "type": "function", "name": "token_symbol", "inputs": [], "outputs": [{ "name": "", "type": "string", "internalType": "string" }], "stateMutability": "view" }, { "type": "function", "name": "total_balance", "inputs": [], "outputs": [{ "name": "", "type": "uint256", "internalType": "uint256" }], "stateMutability": "view" }, { "type": "function", "name": "transfering", "inputs": [{ "name": "reciever", "type": "address", "internalType": "address" }, { "name": "amount", "type": "uint256", "internalType": "uint256" }], "outputs": [], "stateMutability": "nonpayable" }, { "type": "event", "name": "info_", "inputs": [{ "name": "add", "type": "address", "indexed": true, "internalType": "address" }, { "name": "tokens", "type": "uint256", "indexed": true, "internalType": "uint256" }], "anonymous": false }, { "type": "event", "name": "min_started", "inputs": [{ "name": "miner", "type": "address", "indexed": true, "internalType": "address" }], "anonymous": false }, { "type": "event", "name": "min_stopped", "inputs": [{ "name": "miner", "type": "address", "indexed": true, "internalType": "address" }], "anonymous": false }, { "type": "event", "name": "transfer", "inputs": [{ "name": "from", "type": "address", "indexed": true, "internalType": "address" }, { "name": "to", "type": "address", "indexed": true, "internalType": "address" }, { "name": "tokens", "type": "uint256", "indexed": false, "internalType": "uint256" }], "anonymous": false }
];



let web3;
let contract;
let accounts;
const DECIMALS = 18;
const MINING_DURATION_MS = 5 * 60 * 1000;
let currentTokenPriceWei = null;

let isMining = false;
let miningStartTime = null;
let miningIntervalId = null;
let canClaim = false;

const introAnimationContainer = document.getElementById('introAnimationContainer');
const connectWalletContainer = document.getElementById('connectWalletContainer');
const connectStatusMessages = document.getElementById('connectStatusMessages');
const mainUIContainer = document.getElementById('mainUIContainer');
const appHeader = document.getElementById('appHeader');
const dappInterface = document.getElementById('dapp-interface');
const mainStatusMessages = document.getElementById('mainStatusMessages');
const connectButton = document.getElementById('connectButton');
const walletInfoEl = document.getElementById('walletInfo');
const walletAddressEl = document.getElementById('walletAddress')?.querySelector('span');
const networkNameEl = document.getElementById('networkName')?.querySelector('span');
const tokenNameEl = document.getElementById('tokenName');
const tokenSymbolEl = document.getElementById('tokenSymbol');
const tokenPriceEl = document.getElementById('tokenPrice');
const maxLimitEl = document.getElementById('maxLimit');
const userAddressEl = document.getElementById('userAddress');
const userBalanceEl = document.getElementById('userBalance');
const contractMgBalanceEl = document.getElementById('contractMgBalance');
const miningStatusDisplay = document.getElementById('miningStatusDisplay');
const miningTimerDisplay = document.getElementById('miningTimerDisplay');
const miningProgressBarContainer = document.getElementById('miningProgressBarContainer');
const miningProgressBar = document.getElementById('miningProgressBar');
const miningMessage = document.getElementById('miningMessage');
const timerWarning = document.querySelector('.timer-warning');
const startMiningButton = document.getElementById('startMiningButton');
const getTokensButton = document.getElementById('getTokensButton');
const stopMiningButton = document.getElementById('stopMiningButton');
const transferRecipientInput = document.getElementById('transferRecipient');
const transferAmountInput = document.getElementById('transferAmount');
const transferButton = document.getElementById('transferButton');
const buyAmountEthInput = document.getElementById('buyAmountEth');
const buyTokenButton = document.getElementById('buyTokenButton');
const buyPriceInfoEl = document.getElementById('buyPriceInfo');
const sellAmountTokensInput = document.getElementById('sellAmountTokens');
const sellTokenButton = document.getElementById('sellTokenButton');
const eventLogsEl = document.getElementById('eventLogs');
const eventListEl = document.getElementById('eventList');
const blockBackgroundContainer = document.getElementById('block-background-container');


function displayStatus(message, type = 'info', target = 'main') { const targetContainer = target === 'connect' ? connectStatusMessages : mainStatusMessages; if (!targetContainer) { console.error(`Status container not found: ${target}`); return; } if (target === 'connect' && targetContainer.classList.contains('hidden')) { targetContainer.classList.remove('hidden'); } targetContainer.style.opacity = 0; setTimeout(() => { targetContainer.innerHTML = `<p class="status-message ${type}">${message}</p>`; targetContainer.className = `status-box ${type}`; targetContainer.style.opacity = 1; }, 150); console.log(`Status [${type}] (${target}): ${message}`); }
function formatAddress(address) { if (!address) return 'N/A'; if (address === '0x0000000000000000000000000000000000000000') return 'Zero Address (Mint/Burn)'; return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`; }
function formatWei(weiValue, decimals = DECIMALS, format = 'ether') { if (weiValue === null || weiValue === undefined) return 'N/A'; try { if (!web3) return "N/A"; return web3.utils.fromWei(weiValue.toString(), format); } catch (error) { console.error("Error formatting Wei:", weiValue, error); return 'Error'; } }
async function getNetworkName(chainId) { switch (Number(chainId)) { case 1: return 'Ethereum Mainnet'; case 5: return 'Goerli'; case 11155111: return 'Sepolia'; case 137: return 'Polygon Mainnet'; case 80001: return 'Polygon Mumbai'; case 1337: return 'Localhost/Ganache'; default: return `Unknown (${chainId})`; } }
function showSpinner(button, show = true) { const text = button?.querySelector('.btn-text'); const spinner = button?.querySelector('.spinner'); if (!button) return; button.disabled = show; if (text) text.classList.toggle('hidden', show); if (spinner) spinner.classList.toggle('hidden', !show); }
async function handleTransaction(txPromise, buttonElement, successMessage) { if (buttonElement) showSpinner(buttonElement, true); displayStatus('Waiting for transaction confirmation...', 'pending', 'main'); try { const receipt = await txPromise; await new Promise(resolve => setTimeout(resolve, 500)); displayStatus(`${successMessage}. Tx: ${formatAddress(receipt.transactionHash)}`, 'success', 'main'); console.log("Transaction Receipt:", receipt); await updateUIData(); if (buttonElement) showSpinner(buttonElement, false); return true; } catch (error) { console.error("Transaction failed:", error); let errorMessage = error.message; if (error.code === 4001) { errorMessage = "Transaction rejected by user."; } else if (error.message) { const match = error.message.match(/reason="(.*?)"/); if (match && match[1]) { errorMessage = `Transaction Reverted: ${match[1]}`; } else if (error.message.includes('reverted with reason string')) { try { const reasonMatch = error.message.match(/'(.*?)'/); if (reasonMatch && reasonMatch[1]) { errorMessage = `Transaction Reverted: ${reasonMatch[1]}`; } } catch (e) { } } else if (error.message.includes('insufficient funds')) { errorMessage = 'Transaction failed: Insufficient funds for gas.'; } else if (error.message.includes("execution reverted")) { errorMessage = "Transaction Reverted. Check contract logic/inputs or ETH balance."; } else { errorMessage = errorMessage.substring(0, 150) + (errorMessage.length > 150 ? '...' : ''); } } displayStatus(errorMessage, 'error', 'main'); if (buttonElement) showSpinner(buttonElement, false); return false; } }

async function connectWallet(isAutoConnect = false) { if (connectButton && connectButton.disabled) return; if (accounts && accounts.length > 0 && !isAutoConnect) { console.log("connectWallet: Manual click, already connected. Refreshing data."); await updateUIData(); return; } if (window.ethereum) { try { web3 = new Web3(window.ethereum); if (!isAutoConnect) { displayStatus("Requesting account access...", 'pending', 'connect'); if (connectButton) showSpinner(connectButton, true); } console.log("connectWallet: Requesting accounts..."); accounts = await window.ethereum.request({ method: 'eth_requestAccounts' }); console.log("connectWallet: eth_requestAccounts finished."); if (!accounts || accounts.length === 0) { throw new Error("No accounts found/approved."); } console.log("Accounts obtained:", accounts); const chainId = await web3.eth.getChainId(); const networkName = await getNetworkName(chainId); console.log("Network:", networkName, `(ID: ${chainId})`); if (!Array.isArray(contractABI) || contractABI.length === 0 || !web3.utils.isAddress(contractAddress) || contractAddress === "YOUR_FINAL_DEPLOYED_MYGUY_ADDRESS") { throw new Error("DApp Address/ABI invalid or placeholder used."); } contract = new web3.eth.Contract(contractABI, contractAddress); console.log("Contract object created."); if (!isAutoConnect) { displayStatus("Wallet connected!", 'success', 'connect'); await new Promise(resolve => setTimeout(resolve, 300)); } console.log("Hiding Connect Wallet Container (if visible)..."); if (connectWalletContainer) connectWalletContainer.classList.add('hidden'); console.log("Showing main app elements..."); if (mainUIContainer) mainUIContainer.style.display = 'block'; if (appHeader) appHeader.classList.remove('hidden'); if (dappInterface) dappInterface.classList.remove('hidden'); if (blockBackgroundContainer) blockBackgroundContainer.classList.remove('hidden'); console.log("Updating connection status in header..."); updateConnectionStatusInHeader(accounts[0], networkName); console.log("Loading DApp data..."); await updateUIData(); console.log("DApp data loaded."); resetMiningVisualizer(); listenToEvents(); if (connectButton) showSpinner(connectButton, false); } catch (error) { console.error("Wallet connection error:", error); let msg = "Connection failed. Check console."; if (error.code === 4001) msg = "Connection rejected."; else if (error.code === -32002) msg = "Request pending. Check MetaMask."; else if (error.message?.includes("Address/ABI invalid")) { msg = "DApp Config Error!"; alert(msg); } if (!isAutoConnect) displayStatus(msg, 'error', 'connect'); else console.log("Auto-connect failed silently:", msg); updateConnectionStatusInHeader(null, null); if (connectButton) showSpinner(connectButton, false); } } else { if (!isAutoConnect) { displayStatus("MetaMask not detected!", 'error', 'connect'); alert("MetaMask is required."); } else { console.log("Auto-connect skipped: MetaMask not detected."); } if (connectButton) showSpinner(connectButton, false); } }

function updateConnectionStatusInHeader(account, network) { const walletInfoDisplay = document.getElementById('walletInfo'); const walletAddrSpan = walletInfoDisplay?.querySelector('#walletAddress span'); const networkNameSpan = walletInfoDisplay?.querySelector('#networkName span'); const mainUI = document.getElementById('mainUIContainer'); if (account && walletInfoDisplay && walletAddrSpan && networkNameSpan) { walletAddrSpan.textContent = formatAddress(account); networkNameSpan.textContent = network; if (userAddressEl) userAddressEl.textContent = account; walletInfoDisplay.classList.remove('hidden'); console.log("Header connection status updated and shown."); if (blockBackgroundContainer) blockBackgroundContainer.classList.remove('hidden'); } else { console.log("Resetting UI for disconnect/error state."); if (mainUI) mainUI.style.display = 'none'; if (appHeader) appHeader.classList.add('hidden'); if (dappInterface) dappInterface.classList.add('hidden'); if (connectWalletContainer) connectWalletContainer.classList.remove('hidden'); if (walletInfoDisplay) walletInfoDisplay.classList.add('hidden'); if (blockBackgroundContainer) blockBackgroundContainer.classList.add('hidden'); if (userAddressEl) userAddressEl.textContent = '-'; if (tokenNameEl) tokenNameEl.textContent = '-'; if (tokenSymbolEl) tokenSymbolEl.textContent = '-'; if (tokenPriceEl) tokenPriceEl.textContent = '-'; if (buyPriceInfoEl) buyPriceInfoEl.textContent = '- ETH/MG'; if (userBalanceEl) userBalanceEl.textContent = '0'; if (maxLimitEl) maxLimitEl.textContent = 'N/A'; if (contractMgBalanceEl) contractMgBalanceEl.textContent = 'N/A'; if (eventListEl) eventListEl.innerHTML = ''; if (eventLogsEl) eventLogsEl.classList.add('hidden'); displayStatus("Please connect your wallet.", 'info', 'main'); resetMiningStateAndVisualizer(); } }

async function updateUIData() { if (!contract || !accounts || accounts.length === 0) { console.warn("updateUIData skipped."); if (userBalanceEl) userBalanceEl.textContent = 'N/A'; if (maxLimitEl) maxLimitEl.textContent = 'N/A'; if (contractMgBalanceEl) contractMgBalanceEl.textContent = 'N/A'; return; } const currentUserAddress = accounts[0]; console.log(`Fetching contract data for account: ${currentUserAddress}`); if (userBalanceEl) userBalanceEl.textContent = 'Loading...'; if (maxLimitEl) maxLimitEl.textContent = 'Loading...'; if (tokenPriceEl) tokenPriceEl.textContent = 'Loading...'; if (buyPriceInfoEl) buyPriceInfoEl.textContent = 'Loading...'; if (contractMgBalanceEl) contractMgBalanceEl.textContent = 'Loading...'; let name, symbol, priceWei, currentMaxLimit, contractBalanceWei; try { console.log("Fetching name, symbol, price, max_limit, contract MG balance..."); try { [name, symbol, priceWei, currentMaxLimit, contractBalanceWei] = await Promise.all([contract.methods.token_name().call({ from: currentUserAddress }), contract.methods.token_symbol().call({ from: currentUserAddress }), contract.methods.price_per_token().call({ from: currentUserAddress }), contract.methods.max_limit().call({ from: currentUserAddress }), contract.methods.getContractMgBalance().call({ from: currentUserAddress })]); console.log("General info fetched:", { name, symbol, priceWei: priceWei?.toString(), maxLimit: currentMaxLimit?.toString(), contractBalance: contractBalanceWei?.toString() }); currentTokenPriceWei = priceWei ? web3.utils.toBN(priceWei) : null; if (tokenNameEl) tokenNameEl.textContent = name ?? 'N/A'; if (tokenSymbolEl) tokenSymbolEl.textContent = symbol ?? 'N/A'; const priceEth = currentTokenPriceWei ? formatWei(currentTokenPriceWei) : 'N/A'; if (tokenPriceEl) tokenPriceEl.textContent = priceEth; if (buyPriceInfoEl) buyPriceInfoEl.textContent = priceEth; if (maxLimitEl) maxLimitEl.textContent = currentMaxLimit !== undefined ? formatWei(currentMaxLimit) : 'N/A'; if (contractMgBalanceEl) contractMgBalanceEl.textContent = contractBalanceWei !== undefined ? formatWei(contractBalanceWei) : 'N/A'; } catch (infoError) { console.error("ERROR fetching general contract info:", infoError); displayStatus("Error loading some contract info.", "error", "main"); if (tokenNameEl) tokenNameEl.textContent = 'Error'; if (tokenSymbolEl) tokenSymbolEl.textContent = 'Error'; if (tokenPriceEl) tokenPriceEl.textContent = 'Error'; if (buyPriceInfoEl) buyPriceInfoEl.textContent = 'Error'; if (maxLimitEl) maxLimitEl.textContent = 'Error'; if (contractMgBalanceEl) contractMgBalanceEl.textContent = 'Error'; currentTokenPriceWei = null; } console.log("Fetching user balance..."); if (userBalanceEl) { try { if (!web3.utils.isAddress(currentUserAddress)) throw new Error("Invalid user account."); const balanceWei = await contract.methods.getbalance().call({ from: currentUserAddress }); console.log(`Raw balance received: ${balanceWei?.toString()}`); userBalanceEl.textContent = formatWei(balanceWei); console.log(`User balance updated successfully.`); } catch (balanceError) { console.error("Detailed error fetching user balance:", balanceError); userBalanceEl.textContent = 'Error'; displayStatus("Error fetching balance.", "error", 'main'); } } else { console.warn("userBalanceEl not found."); } console.log("Contract data update process finished."); } catch (outerError) { console.error("Outer UNEXPECTED ERROR during updateUIData:", outerError); displayStatus(`Critical error loading data.`, 'error', 'main'); } }

function updateMiningVisualizer() { if (!isMining || !miningStartTime) { resetMiningVisualizer(); return; } const elapsedMs = Date.now() - miningStartTime; const remainingMs = Math.max(0, MINING_DURATION_MS - elapsedMs); const progressPercent = Math.min(100, (elapsedMs / MINING_DURATION_MS) * 100); const remainingSecondsTotal = Math.floor(remainingMs / 1000); const minutes = Math.floor(remainingSecondsTotal / 60); const seconds = remainingSecondsTotal % 60; const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; if (miningStatusDisplay) miningStatusDisplay.textContent = "Status: Mining..."; if (miningTimerDisplay) miningTimerDisplay.textContent = `Time Left: ${formattedTime}`; if (miningProgressBar) miningProgressBar.style.width = `${progressPercent}%`; if (miningProgressBarContainer) miningProgressBarContainer.classList.remove('hidden'); if (miningMessage) miningMessage.textContent = "Mining in progress..."; if (timerWarning) timerWarning.classList.remove('hidden'); if (remainingMs <= 0) { clearInterval(miningIntervalId); miningIntervalId = null; isMining = false; canClaim = true; if (miningStatusDisplay) miningStatusDisplay.textContent = "Status: Ready to Claim"; if (miningTimerDisplay) miningTimerDisplay.textContent = `Time Left: 00:00`; if (miningMessage) { miningMessage.textContent = "Tokens ready for claiming!"; miningMessage.classList.add('ready'); } if (timerWarning) timerWarning.classList.add('hidden'); if (miningProgressBar) miningProgressBar.style.width = `100%`; if (startMiningButton) startMiningButton.disabled = false; if (stopMiningButton) stopMiningButton.disabled = true; if (getTokensButton) getTokensButton.disabled = false; } }
function resetMiningVisualizer() { if (miningStatusDisplay) miningStatusDisplay.textContent = "Status: Idle"; if (miningTimerDisplay) miningTimerDisplay.textContent = `Time Left: 05:00`; if (miningProgressBar) miningProgressBar.style.width = `0%`; if (miningProgressBarContainer) miningProgressBarContainer.classList.add('hidden'); if (miningMessage) { miningMessage.textContent = 'Click "Start Mining" to begin.'; miningMessage.classList.remove('ready'); } if (timerWarning) timerWarning.classList.add('hidden'); if (startMiningButton) startMiningButton.disabled = false; if (stopMiningButton) stopMiningButton.disabled = true; if (getTokensButton) getTokensButton.disabled = true; }
function resetMiningStateAndVisualizer() { if (miningIntervalId) { clearInterval(miningIntervalId); miningIntervalId = null; } isMining = false; miningStartTime = null; canClaim = false; resetMiningVisualizer(); }

async function startMining() { if (!contract || !accounts || accounts.length === 0) return displayStatus("Connect wallet first.", 'error', 'main'); if (isMining || canClaim) return displayStatus("Already mining or ready to claim.", 'info', 'main'); const success = await handleTransaction(contract.methods.start_mining().send({ from: accounts[0] }), startMiningButton, "Mining started on-chain!"); if (success) { isMining = true; canClaim = false; miningStartTime = Date.now(); if (startMiningButton) startMiningButton.disabled = true; if (stopMiningButton) stopMiningButton.disabled = false; if (getTokensButton) getTokensButton.disabled = true; if (miningIntervalId) clearInterval(miningIntervalId); miningIntervalId = setInterval(updateMiningVisualizer, 1000); updateMiningVisualizer(); displayStatus("Visual mining timer started.", 'info', 'main'); } else { if (startMiningButton) showSpinner(startMiningButton, false); if (startMiningButton) startMiningButton.disabled = false; } }
async function stopMining() { if (!contract || !accounts || accounts.length === 0) return displayStatus("Connect wallet first.", 'error', 'main'); if (!isMining && !canClaim) return; const success = await handleTransaction(contract.methods.stop_mining().send({ from: accounts[0] }), stopMiningButton, "Mining stopped on-chain!"); if (success) { resetMiningStateAndVisualizer(); displayStatus("Visual mining timer stopped.", 'info', 'main'); } else { if (stopMiningButton) showSpinner(stopMiningButton, false); } }
async function getMinedTokens() { if (!contract || !accounts || accounts.length === 0) return displayStatus("Connect wallet first.", 'error', 'main'); displayStatus("Attempting to claim tokens...", 'pending', 'main'); const success = await handleTransaction(contract.methods.get_your_tokens().send({ from: accounts[0] }), getTokensButton, "Claim tokens transaction sent!"); if (success) { resetMiningStateAndVisualizer(); } else { if (getTokensButton) showSpinner(getTokensButton, false); if (getTokensButton) getTokensButton.disabled = false; canClaim = true; } }
async function transferTokens() { if (!contract || !accounts || accounts.length === 0) return displayStatus("Connect wallet first.", 'error', 'main'); const recipient = transferRecipientInput?.value.trim(); const amount = transferAmountInput?.value.trim(); if (!web3.utils.isAddress(recipient)) return displayStatus("Invalid recipient address.", 'error', 'main'); if (!amount || parseFloat(amount) <= 0) return displayStatus("Invalid amount.", 'error', 'main'); try { const amountWei = web3.utils.toWei(amount, 'ether'); const success = await handleTransaction(contract.methods.transfering(recipient, amountWei).send({ from: accounts[0] }), transferButton, `Transfer successful`); if (success) { if (transferRecipientInput) transferRecipientInput.value = ''; if (transferAmountInput) transferAmountInput.value = ''; } } catch (error) { console.error("Transfer prep error:", error); } }
async function buyTokens() { if (!contract || !accounts || accounts.length === 0) return displayStatus("Connect wallet first.", 'error', 'main'); const amountEth = buyAmountEthInput?.value.trim(); if (!amountEth || parseFloat(amountEth) <= 0) return displayStatus("Invalid ETH amount.", 'error', 'main'); try { const amountWeiToSend = web3.utils.toWei(amountEth, 'ether'); const success = await handleTransaction(contract.methods.buy_token().send({ from: accounts[0], value: amountWeiToSend }), buyTokenButton, `Buy tokens transaction sent`); if (success) { if (buyAmountEthInput) buyAmountEthInput.value = ''; } } catch (error) { console.error("Buy Token prep error:", error); } }

async function sellTokens() {
    if (!contract || !accounts || accounts.length === 0) return displayStatus("Connect wallet first.", 'error', 'main');
    if (!sellTokenButton || !sellAmountTokensInput) { console.error("Sell elements not ready!"); return displayStatus("Error: UI elements not loaded.", 'error', 'main'); }

    const amountToSellStr = sellAmountTokensInput.value.trim();
    if (!amountToSellStr || parseFloat(amountToSellStr) <= 0) {
        return displayStatus("Please enter a valid amount of MG tokens.", 'error', 'main');
    }

    displayStatus("Attempting sell transaction...", 'pending', 'main');

    try {
        const amountToSellWholeString = amountToSellStr;

        if (contract.methods.sell_tokens && typeof contract.methods.sell_tokens === 'function') {
            await handleTransaction(
                contract.methods.sell_tokens(amountToSellWholeString).send({ from: accounts[0] }),
                sellTokenButton,
                "Sell transaction sent (Check results)"
            );
            if (sellAmountTokensInput) sellAmountTokensInput.value = '';

        } else {
            throw new Error("sell_tokens function not found or invalid in ABI!");
        }
    } catch (error) {
        console.error("Error during sell token process:", error);
        let errorMsg = `Sell Error: ${error.message.substring(0, 100)}...`;
        if (error.message.includes("not found or invalid in ABI")) {
            errorMsg = "Sell Error: Function definition mismatch. Check ABI.";
        } else if (error.message.includes("execution reverted")) {
            errorMsg = "Sell Tx Reverted. Check contract logic/balance.";
        }
        displayStatus(errorMsg, 'error', 'main');
        showSpinner(sellTokenButton, false);
    }
}

function addEventToList(logMessage) { if (!eventListEl || !eventLogsEl) return; const li = document.createElement('li'); li.innerHTML = logMessage; eventListEl.insertBefore(li, eventListEl.firstChild); while (eventListEl.children.length > 20) { eventListEl.removeChild(eventListEl.lastChild); } eventLogsEl.classList.remove('hidden'); }
function listenToEvents() { if (!contract) return; console.log("Starting event listeners..."); contract.events.allEvents({ fromBlock: 'latest' }).on('data', async (event) => { console.log("Event:", event.event, event.returnValues); let simpleMessage = ''; const time = `<span class="event-time">${new Date().toLocaleTimeString()}</span>`; let involvedUser = false; let isContractInvolved = false; let from = event.returnValues.from; let to = event.returnValues.to; let miner = event.returnValues.miner; let add = event.returnValues.add; if (accounts && accounts.length > 0) { involvedUser = (to === accounts[0] || from === accounts[0] || miner === accounts[0] || add === accounts[0]); } if (from === contractAddress || to === contractAddress) { isContractInvolved = true; } if (event.event === 'transfer' || event.event === 'info') { if (involvedUser) { try { const balanceWei = await contract.methods.getbalance().call({ from: accounts[0] }); if (userBalanceEl) userBalanceEl.textContent = formatWei(balanceWei); } catch { /* ignore */ } } if (isContractInvolved) { try { if (contractMgBalanceEl && contract.methods.getContractMgBalance) { const contractBalWei = await contract.methods.getContractMgBalance().call({ from: accounts[0] }); if (contractMgBalanceEl) contractMgBalanceEl.textContent = formatWei(contractBalWei) ?? 'N/A'; } } catch (e) { console.error("Failed to update contract MG balance on event", e); if (contractMgBalanceEl) contractMgBalanceEl.textContent = 'Error'; } } if (from === '0x0000000000000000000000000000000000000000' || event.event === 'info') { simpleMessage = `${time} <span class="event-action">Tokens Acquired</span>`; try { if (maxLimitEl && contract.methods.max_limit) { const currentMaxLimit = await contract.methods.max_limit().call({ from: accounts[0] }); if (maxLimitEl) maxLimitEl.textContent = formatWei(currentMaxLimit); } } catch { /* ignore */ } } else if (event.event === 'transfer') { simpleMessage = `${time} <span class="event-action">Transfer Sent/Received</span>`; } } else if (event.event === 'min_started') { simpleMessage = `${time} <span class="event-action">Mining Started</span>`; if (involvedUser && !isMining && !canClaim) { if (miningStatusDisplay) miningStatusDisplay.textContent = "Status: Mining (Event)"; } } else if (event.event === 'min_stopped') { simpleMessage = `${time} <span class="event-action">Mining Stopped</span>`; if (involvedUser) { if (isMining || canClaim) { resetMiningStateAndVisualizer(); } if (miningStatusDisplay) miningStatusDisplay.textContent = "Status: Idle (Event)"; } } if (simpleMessage) { addEventToList(simpleMessage); } }).on('error', (error, receipt) => { console.error('Event subscription error:', error, receipt); const time = `<span class="event-time">${new Date().toLocaleTimeString()}</span>`; addEventToList(`${time} <span class="event-action error">Event Listener Error</span>`); }); }

async function init() { console.log("INIT (app.js): Starting initialization..."); const introContainer = document.getElementById('introAnimationContainer'); const connectPage = document.getElementById('connectWalletContainer'); const mainUI = document.getElementById('mainUIContainer'); if (mainUI) mainUI.style.display = 'none'; if (blockBackgroundContainer) blockBackgroundContainer.classList.add('hidden'); if (introContainer && connectPage) { connectPage.classList.add('hidden'); connectPage.style.display = 'none'; console.log("INIT: Setting up intro timeout..."); setTimeout(() => { console.log("TIMEOUT: Intro finished."); if (introContainer) introContainer.classList.add('hidden'); checkConnectionAndShowUI(); }, 3000); } else { console.warn("INIT WARN: Intro container not found, checking connection directly."); checkConnectionAndShowUI(); } console.log("INIT: Adding event listeners..."); if (connectButton) connectButton.addEventListener('click', () => connectWallet(false)); else console.error("Connect button not found"); if (startMiningButton) startMiningButton.addEventListener('click', startMining); if (stopMiningButton) stopMiningButton.addEventListener('click', stopMining); if (getTokensButton) getTokensButton.addEventListener('click', getMinedTokens); if (transferButton) transferButton.addEventListener('click', transferTokens); if (buyTokenButton) buyTokenButton.addEventListener('click', buyTokens); if (sellTokenButton) sellTokenButton.addEventListener('click', sellTokens); if (window.ethereum) { window.ethereum.on('accountsChanged', () => window.location.reload()); window.ethereum.on('chainChanged', () => window.location.reload()); console.log("INIT: Ethereum listeners added."); } resetMiningVisualizer(); console.log("INIT: Initialization complete setup."); }

async function checkConnectionAndShowUI() { console.log("checkConnectionAndShowUI: Checking connection state..."); if (window.ethereum) { try { const availableAccounts = await window.ethereum.request({ method: 'eth_accounts' }); if (availableAccounts && availableAccounts.length > 0) { console.log("checkConnectionAndShowUI: Found existing connection/permissions."); await connectWallet(true); } else { console.log("checkConnectionAndShowUI: No existing connection found."); if (connectWalletContainer) { connectWalletContainer.style.display = 'flex'; connectWalletContainer.classList.remove('hidden'); displayStatus("Please connect your wallet.", 'info', 'connect'); console.log("checkConnectionAndShowUI: Connect page displayed."); } else { console.error("checkConnectionAndShowUI: Connect page container not found!"); } } } catch (err) { console.error("checkConnectionAndShowUI: Error checking existing accounts:", err); if (connectWalletContainer) { connectWalletContainer.style.display = 'flex'; connectWalletContainer.classList.remove('hidden'); displayStatus("Could not check connection. Please connect.", 'error', 'connect'); } } } else { console.log("checkConnectionAndShowUI: MetaMask not detected."); if (connectWalletContainer) { connectWalletContainer.style.display = 'flex'; connectWalletContainer.classList.remove('hidden'); displayStatus("Please install MetaMask to use this DApp.", 'error', 'connect'); } } }

document.addEventListener('DOMContentLoaded', init);